---
layout: post
title: "알고리즘 문제 풀이7"
date: 2019-10-20 12:00:00
author: ckw1140
---

## 알고리즘 문제 풀이 7

최근에 푼 재미있는 문제들을 포스팅 해보겠습니다.

[\[BOJ 9208 링월드\]](https://www.acmicpc.net/problem/9208)
-
이 문제는 원형으로 나열되어 있는 $$M$$개의 도시가 있고, 연속된 도시들로 이루어진 $$N$$개의 구간이 있을 때, $$N$$개의 구간에서 겹치지 않게 도시를 하나씩 고를 수 있는가를 답해야 하는 문제입니다.

우선, M개의 도시가 원형이 아니라 선형으로 나열되어 있다면 어떨까요?
이 문제는 매우 간단한 그리디로 풀 수 있습니다.
왼쪽 도시에서부터 쭉 보면서 현재 도시를 고를 수 있는 구간들 중 오른쪽 끝 도시가 가장 왼쪽에 있는 구간에게 현재 도시를 할당하는 것이 최적입니다.
따라서 이 알고리즘으로 모든 구간에게 도시를 할당할 수 있으면 답은 YES, 그렇지 않으면 NO 라는 것을 쉽게 알 수 있습니다.

이 알고리즘은 $$O(NlogN)$$ 에 동작하도록 작성할 수 있습니다.

그렇다면, 도시가 원형으로 나열된 문제는 어떻게 풀 수 있을까요?

이 문제가 bipartite matching 에서 perfect matching 이 존재하는지를 묻는 문제라는 점에서 홀의 결혼 정리의 관점에서 이 문제를 관찰해 볼 수 있습니다.

홀의 결혼 정리에 의해 perfect matching 이 존재하는 것과 구간들의 집합의 임의의 부분집합 $$A$$를 생각했을 때, $$A$$의 크기보다 $$A$$에 포함된 구간들의 합집합의 크기가 더 크거나 같다는 것이 필요 충분 조건임을 알 수 있습니다.

이 때, 원형 버전의 문제에 대응되는 아래와 같은 선형 버전의 문제를 생각해 봅시다.
>$$2M$$개의 도시가있고, 원형 버전의 문제에서 주어진 구간 [$$l_i, r_i$$]에 대해 $$l_i \leq r_i$$이면 구간 [$$l_i, r_i$$], [$$l_i + M, r_i + M$$]을 추가하고, $$l_i > r_i$$이면 구간 [$$l_i, r_i + M$$]을 추가한다.

우선, 선형 버전에서 홀의 결혼 정리의 조건이 성립한다면, 원형 버전에서 홀의 결혼 정리의 조건이 성립함은 자명합니다.

그렇다면 원형 버전에서 홀의 결혼 정리의 조건이 성립하면 선형 버전에서도 홀의 결혼 정리의 조건이 성립할까요?

$$N \leq M$$ 이라면 이 조건도 성립한다는 것을 어렵지 않게 증명할 수 있습니다.

우선 부정을 가정합시다.
즉, 원형 버전에서 홀의 결혼 정리의 조건이 성립할 때, 선형 버전에서 홀의 결혼 정리의 조건이 성립하지 않는 구간들의 어떤 부분 집합 $$A$$가 존재한다는 것을 가정하는 것입니다.
우선, 집합 $$A$$를 원소인 구간들의 합집합이 연속된 도시들로 구성된 경우라고 생각하여도 문제가 없습니다.
왜냐하면, 구간들의 합집합이 불연속인 도시들로 구성된 경우 연속된 도시들과 대응되는 부분 집합으로 쪼갤 수 있고, 이 중 적어도 하나는 홀의 결혼 정리의 조건을 만족하지 않을 것이기 때문입니다.

따라서 $$A$$의 원소들의 합집합은 선형 버전의 도시 배열에서 연속인 도시의 구간을 나타냅니다.

한편, 이 도시 구간의 길이가 $$M$$보다 작다면 원형 버전의 문제로 정확히 대응 시킬수 있으므로 홀의 결혼 정리의 조건을 당연히 만족시킬 것입니다. 따라서 이 도시 구간의 길이는 $$M$$보다 큽니다.

도시 구간의 길이가 $$M$$보다 크면서 홀의 결혼 정리의 조건을 만족하지 않으려면 당연히 구간은 $$N$$개보다 많이 선택되었을 것입니다.
그러면 $$A$$ 당연히 원형 버전에서 같은 구간에서 파생된 한 쌍의 구간들중 적어도 한 쌍을 모두 포함하고 있을 것입니다.
우리는 그러한 쌍 중 가장 왼쪽에 있는 한 쌍을 골라서 중 오른쪽에 있는 구간을 남기고 왼쪽에 있는 구간을 모두 제외한 집합을 생각해 봅시다.

이 집합은 원래 생각한 $$A$$에 비해 원소의 합집합에 대응되는 도시의 개수는 $$M$$개 이상이 줄어들며 구간의 개수(집합의 크기)는 $$N$$개 이하가 줄어들기 때문에 $$N \leq M$$에서 남은 구간들의 집합 또한 홀의 결혼 정리의 조건을 만족시키지 않아야 하는데, 이는 원형 버전의 문제에 대응 시킬수 있는 집합이므로 모순입니다.

따라서 증명을 완료하였습니다.

따라서 $$N \leq M$$이라면 원형 버전의 문제에서 perfect matching 이 존재한다는 것과 그에 대응되는 선형 버전의 문제에서 perfect matching이 존재한다는 것이 동치입니다.

따라서 위에서 제시한 선형 버전을 해결하는 알고리즘을 통해 원형 버전의 문제도 $$O(NlogN)$$ 시간에 해결할 수 있습니다.

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;

int M, N;
vector<pii> seg;
priority_queue<int> pq;

int Xn;
vector<int> X;

void main2() {
    scanf("%d %d", &M, &N);

    seg.clear();
    X.clear();
    for(int i = 0; i < N; i++) {
        int l, r; scanf("%d %d", &l, &r);
        if(l <= r) {
            seg.push_back(pii(l, r));
            seg.push_back(pii(l + M, r + M));
            X.push_back(l);
            X.push_back(l + M);
        }
        else {
            seg.push_back(pii(l, r + M));
            X.push_back(l);
        }
    }
    X.push_back(2 * M);

    sort(seg.begin(), seg.end());
    sort(X.begin(), X.end());
    X.resize(unique(X.begin(), X.end()) - X.begin());
    Xn = X.size();

    if(M < N) {
        printf("NO\n");
        return;
    }
    
    while(!pq.empty()) pq.pop();

    int pos = 0;
    for(int i = 0; i < Xn - 1; i++) {
        while(pos < seg.size() && seg[pos].first == X[i]) {
            pq.push(-seg[pos].second);
            pos++;
        }

        int x = X[i];
        while(x < X[i + 1] && !pq.empty()) {
            int t = -pq.top(); pq.pop();

            if(t < x) {
                printf("NO\n");
                return;
            }
            x++;
        }
    }
    if(pq.empty()) printf("YES\n");
    else printf("NO\n");
}

int TC;
int main() {
    scanf("%d", &TC);
    while(TC--) main2();
}

```