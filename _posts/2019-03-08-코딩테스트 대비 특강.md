---
layout: post
title:  "코딩테스트 대비 특강"
date:   2019-03-07 09:00:00
author: blisstoner
tags: [test]
---

이 포스트는 3월 1일과 2일에 걸쳐 진행한 코딩테스트 특강의 내용을 기술한 포스트입니다. BFS/DFS, 백트래킹, 시뮬레이션 개념을 알고 있고 기출 문제에 손을 댈 수는 있는데 100% 푼다는 확신은 없어서 개념을 다시 정리하고 모의고사를 쳐보고 싶은 분이 이 포스트를 보신다면 많은 도움이 될 것입니다.

특강의 슬라이드는 [여기](https://blog.encrypted.gg/772)에서 확인할 수 있습니다. **이 특강은 개인이 준비한 특강이고, 특히 특정 기업의 채용절차와 아무런 관련이 없습니다.**

![](/assets/images/코딩테스트-대비-특강/슬라이드1.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드2.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드3.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드4.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드5.PNG)
무엇보다 먼저 기초 지식과 자주 실수하는 점을 짚고 넘어가겠습니다. 함수의 인자로 구조체/pair/tuple/vector를 넘길 때 어떤 식으로 처리가 되는지를 명확하게 알고 있어야 합니다. 이를 알지 못할 경우 시간초과가 발생하거나 의도하지 않은 대로 동작할 수 있습니다.

Q1부터 Q8까지 8가지의 질문이 있는데 한 번 결과를 고민해보세요. 답은 문제가 다 나온 후에 적혀있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드6.PNG)
첫 번째 질문은 pair를 함수의 인자로 보낼 때 어떤 일이 발생할까에 관한 질문입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드7.PNG)
그 다음은 pair대신 tuple입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드8.PNG)
그 다음은 구조체입니다. 나머지 문제들도 특강에 참여한 사람들의 정답률이 60% 아래였지만 특히 이 문제의 경우 정답률이 30%가 채 되지 않았습니다. 정답을 맞춰보세요.

![](/assets/images/코딩테스트-대비-특강/슬라이드9.PNG)
이제는 구조체가 class로 바뀌었네요.

![](/assets/images/코딩테스트-대비-특강/슬라이드10.PNG)
이번에는 구조체인데 배열이 아니라 포인터입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드11.PNG)
마찬가지로 구조체가 class로 바뀌었습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드12.PNG)
이 문제에서는 코드의 시간복잡도를 물어보고 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드13.PNG)
마지막은 vector를 함수의 인자로 넘길 때에 관한 질문입니다. 이제 다음 슬라이드부터는 이 8문제에 대한 답이 있으니 미리 자신이 생각한 답을 기록해두고 실제 정답과 비교해보세요.

![](/assets/images/코딩테스트-대비-특강/슬라이드14.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드15.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드16.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드17.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드18.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드19.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드20.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드21.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드22.PNG)
어떤가요? 풀만했나요? 다 맞춘 분이 굉장히 드물 것으로 예상됩니다. pair, tuple, vector를 넘기면 객체의 복사본을 넘긴다는 것에 주의해야 합니다. 만약 복사본이 아니라 원본을 넘기고 싶은 상황이면 참조자를 이용해야 합니다. 만약 참조자가 익숙하지 않으면 개인적으로 공부를 하시는 것을 추천드립니다.

구조체/class 또한 복사본을 넘깁니다. 특히 3번째와 같이 구조체 내에 배열이 있을 경우 그 배열의 내용 전체를 복사해서 넘기기 때문에 함수에서 값을 수정한다고 해도 원본에 영향을 주지 않음에 조심해야 합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드23.PNG)
그 다음으로 다룰 부분은 메모리 구조입니다. 지역 변수, 전역 변수, 동적으로 할당한 변수들이 각각 어느 메모리에 올라가는지는 전공생의 경우 시스템 프로그래밍이나 운영체제와 같은 과목에서 배웠을 것입니다. 특강에서는 딱 코딩테스트를 진행할 때 필요한 만큼만 짚고 넘어갈 것이지만 추후에 기술면접을 대비하기 위해서는 이 부분을 반드시 정확하게 공부하고 가시길 바랍니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드24.PNG)
프로그램이 사용하는 메모리는 크게 `Code, Data, BSS, Heap, Stack`이라는 5개의 영역으로 나눌 수 있습니다. 이 5개의 영역 각각에 어떤 것이 저장되는지는 슬라이드에 나와있으나 코딩테스트를 위해서는 다른 것은 크게 중요하지 않으나 Stack 영역에 지역변수와 함수의 인자가 올라간다는 사실을 기억하세요.

![](/assets/images/코딩테스트-대비-특강/슬라이드25.PNG)
이 5개 영역에서 소비한 메모리의 총합이 채점 환경에서 계산하는 메모리의 양입니다. 만약 메모리를 주어진 제한보다 더 사용하게 되면 메모리 초과가 발생합니다.

그런데 일부 채점 환경에서는 전체 메모리 제한과 별개로 스택 메모리가 1MB로 제한되기도 합니다. 그리고 Visual Studio 2017, Windows에서 MinGW를 이용한 GCC 또한 별도로 설정을 변경하지 않으면 스택 메모리가 1MB로 제한됩니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드26.PNG)
스택 메모리가 1MB로 제한되면 지역 변수를 1MB 이상 잡았을 때, 혹은 재귀의 깊이가 깊어질 때 런타임 에러가 발생합니다. 1MB는 대략 int 25만개 정도이고, 재귀의 깊이가 허용되는 정도는 함수의 인자가 몇 개인지, 함수 내에서 사용한 지역 변수가 몇 개인지에 따라 다르지만 보통 1MB에서는 20000-40000번 정도의 깊이를 가진 프로그램이 정상적으로 동작하지 못하고 런타임 에러가 발생합니다. 슬라이드에 적혀있는 코드는 3,500,000번의 깊이를 가진 프로그램으로, 스택 메모리가 1MB로 제한된 곳에서 실행시켜보면 실제로 프로그램이 `DONE ^__^`을 출력하지 못하고 비정상적으로 죽는 것을 확인할 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드27.PNG)
그렇기 때문에 채점 환경에서 메모리 제한과 별도로 스택 메모리가 1MB로 제한된다면 지역 변수를 많이 잡지 말고 재귀 또한 너무 깊어지지 않도록 해야 합니다.

보통 Tree DP 문제를 DFS로 풀 때 재귀 깊이에 관한 문제가 많이 생기곤 하는데, 딱히 코딩테스트에 나올만한 문제는 아니어서 재귀의 깊이는 걱정하지 않으셔도 되는데, 지역 변수를 너무 많이 잡아 런타임 에러가 발생하는 것은 조심해야 합니다.

스택 메모리의 제한이 없다면 지역 변수를 주어진 메모리 제한 내에서 얼마든지 많이 잡아도 됩니다. 그렇지만 보통 알고리즘 문제를 풀 때에는 지역 변수 대신 전역 변수를 많이 활용하는 편이긴 합니다. 아마 저지 사이트에서 문제를 풀 때 다른 사람의 정답 코드를 보면 프로그램 내에서 쓰일 각종 변수들을 전역에 모조리 두는 것을 많이 봤을 것입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드28.PNG)
N의 제한으로 알고리즘을 유추하는 것은 굉장히 중요합니다. 엄밀히 말해서 알고리즘을 유추한다기 보다는, 내가 생각한 알고리즘이 이 문제의 N 제한에서 통과될 수 있는가를 판단하는 것입니다.

컴퓨터는 1초에 대략 1억에서 3억번 정도 연산을 할 수 있습니다. 그 연산이 간단한 비트 연산인지, 아니면 다소 높은 CPU cycle을 요구하는 나누기나 곱하기 등의 연산인지에 따라 다소 차이는 있지만 적당히 어림잡아 계산을 할 때의 이야기입니다.

슬라이드에 나와있는 이 기준이 절대적인 것은 아닙니다. 예를 들어 N이 10,000인데도 가벼운 연산만 들어있을 경우 $$O(N^2)$$이 통과될 수 있습니다. 반대로 N이 500,000인데도 무거운 연산이 많을 경우 $$O(NlgN)$$이 시간초과가 발생할 수 있습니다. 그렇기에 이 표를 맹신하지는 마시고 어느 정도의 경향을 파악하는데 사용하시면 됩니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드29.PNG)
알고리즘 문제를 풀 땐 디버그 모드로 디버깅을 하지 않는 것이 좋습니다. 길어봐야 200줄 안의 짧은 프로그램이고 시간이 촉박하기에 디버그 모드에서 중단점을 정하고 한 줄 한 줄 진행하는 것은 너무 시간 낭비입니다. 디버그 모드 대신 군데군데 출력을 해서 오류를 잡도록 합시다.

그러나 디버그 모드는 런타임 에러가 발생하는 입력을 알고 있을 때 굉장히 유용합니다. Visual Studio의 디버그 모드를 활용해 어느 줄에서 오류가 발생했는지 알 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드30.PNG)
주어진 코드는 2를 0으로 나눈 연산을 수행합니다. 디버그 모드로 프로그램을 실행하면 이처럼 어디서 문제가 발생했는지를 쉽게 알 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드31.PNG)
이 코드는 STL 스택에 2번 push한 후 3번 pop하기 때문에 11번 줄에서는 비어있는 스택에 pop 명령을 하게 되어 오류가 발생합니다. 이럴 때 Visual Studio는 STL 코드의 특정 줄에서 문제가 생겼음을 알려주지만 현재 내 프로그램의 어느 줄에서 문제가 생겼는지를 알려주지 않아 조금 불편합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드32.PNG)
이 때는 무시를 눌러 계속 진행시키고 상단의 스택 프레임을 보면 내 프로그램의 어느 줄에서 문제가 생겼는지를 알 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드33.PNG)
코딩테스트에서 로컬에 Visual Studio가 설치되어있는 경우가 많습니다. Visual Studio를 자주 써보았다면 상관없지만 그렇지 않다면 에러메시지의 의미를 파악하지 못해 시간 낭비를 할 수 있습니다. 몇 가지 유명한 에러메시지를 짚고 넘어가겠습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드34.PNG)
`Error C2872 : ambigiuous symbol(모호한 기호입니다)`, `Error C2365 : redefinition; previous definition was 'function'(재정의: 이전 정의는 '함수'입니다.)`

이 두 에러는 std namespace 내에 이미 정의되어 있는 변수/함수/클래스의 이름과 동일한 변수를 선언했을 때 발생할 수 있는 에러입니다. 예를 들어 내가 rank라는 변수를 선언했을 때, std namespace 안에 rank라는 이름의 클래스가 존재하기 때문에 코드 내의 rank가 내가 선언한 변수인지, rank 클래스를 의미하는지 모호해져 발생하는 오류입니다.

이런 에러를 발생시키지 않기 위해 std namespace 안에 어떤 클래스, 함수가 있는지 다 외울 필요는 없고, 그냥 오류가 발생할 경우 변수명을 수정하면 쉽게 해결할 수 있습니다. 예를 들어 앞 글자를 대문자로 만든다거나, 뒤에 언더바를 붙인다거나 하는 방법이 있겠습니다. max, end, hash, map, set, y0, y1, max_element 등의 변수명에서도 마찬가지 오류가 발생합니다. 

![](/assets/images/코딩테스트-대비-특강/슬라이드35.PNG)
`Error C2065 : undeclared identifier (선언되지 않은 식별자입니다.)` 에러는 해당 변수가 선언 전에 사용되었다는 의미입니다. 당황하지 말고 그 변수를 먼저 선언해주시면 됩니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드36.PNG)
`Error C4996 : This function or variable may be unsafe(선언되지 않은 식별자입니다.)` 에러는 다른 컴파일러에서는 찾아볼 수 없는 에러인데, scanf 함수가 보안 상 취약한 부분이 있기 때문에 이 함수를 사용하지 말라고 하는 에러메시지입니다. `#define _CRT_SECURE_NO_WARNINGS` 혹은 `#pragma warning(disable : 4996)` 를 코드 상단에 삽입함으로서 해결할 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드37.PNG)
그 외 자주 실수하는 점들은 슬라이드를 참고하세요. 꼭 이 항목들이 아니더라도 맞왜틀을 해본 본인의 경험을 되새겨봅시다.

![](/assets/images/코딩테스트-대비-특강/슬라이드38.PNG)
그 다음으로 다룰 부분은 C++98과 C++11의 차이입니다. 이런 사소한걸 대체 왜 알아야하나 싶을 수도 있는데, 이런 것 때문에 괜히 시간낭비를 할 수도 있습니다. 같은 C++에도 다양한 컴파일러가 존재하고 컴파일러마다 제공하는 함수가 조금씩 다른 경우도 있습니다.  그리고 동일한 컴파일러임에도 불구하고 버전이 올라감에 따라 이전에는 지원되지 않던 기능이 추가로 지원되기도 합니다. 반대로 말하면, 높은 버전에서만 사용할 수 있는 기능을 가지고 코딩을 다 했는데 채점 환경의 버전이 더 낮으면 서버에서 컴파일 에러가 발생해 코드를 갈아엎어야 할 수도 있습니다. 그렇기에 높은 버전에서만 사용할 수 있는 기능들이 무엇인지를 알고 있는 것이 좋습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드39.PNG)
C++98, C++03, C++07, C++11, C++14, C++17과 같은 C++ 표준은 ISO에서 주기적으로 정합니다. 그리고 GCC/Clang/MSVC 등의 C++ 컴파일러들은 이 표준을 참고해 버전을 업데이트하면서 기능을 추가합니다. 예를 들어 GCC의 경우 6.x버전 이전에는 기본 컴파일 옵션이 C++98이었고 이후 C++14로 변경되었습니다. 단 C++11, C++14의 기능 자체는 5.x 버전에 다 추가가 되었습니다. 보통 채점 서버는 GCC 컴파일러이고 C++11에서 새로 추가된 기능이 많기 때문에 C++11 이상에서 컴파일을 해주지만 시험 환경에 따라 그렇지 않은 경우도 있습니다. 그리고 로컬에 Visual Studio 2017만 설치되어 있다던가 하는 이유로 애초에 로컬에서 GCC 컴파일러 대신 MSVC로 컴파일을 해야 하는 경우도 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드40.PNG)
코딩테스트를 칠 때 MSVC와 GCC 사이에서 동작이 다른 부분은 거의 없습니다. 다만 알고리즘 문제를 풀 때 확실히 차이가 느껴질 수 있는 기능은 `VLA(Variable Length Array)`입니다. MSVC는 VLA를 지원하지 않는 반면 GCC는 VLA를 지원합니다.
예를 들어 채점 서버는 GCC이고 C++11 이상을 지원하는 버전인데 개발 환경은 MSVC라고 합시다. 이 경우 로컬에서는 VLA를 사용한 코드에서 컴파일 에러가 발생하나 채점 서버에서는 잘 동작합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드41.PNG)
사실 앞의 예시와 같이 로컬에서는 안되는데 채점 서버에서 되는 경우도 바람직하지 않지만 적어도 로컬에서 짠 코드가 채점 서버에서는 잘 돌아가니 그나마 괜찮습니다. 더 심각한 것은 로컬에서는 되는데 채점 서버에서 안되는 경우입니다. 예를 들어 로컬의 환경은 MSVC이고 채점 서버는 GCC, C++98인 상황을 생각해봅시다. C++11에서 추가된 기능을 로컬에서는 사용할 수 있는데 채점 서버에서는 사용할 수 없어 제출시 컴파일 에러가 발생합니다. 이 말은 코드를 다 완성해놓고 다시 다 갈아엎어야 한다는 이야기이죠. 그러므로 C++11에서 추가된 기능을 잘 파악하고 있다가 코딩테스트를 치러 갔을 때 채점 환경을 꼭 물어보고, C++11이 지원되지 않는다고 하면 해당 기능들을 사용하지 않고 코드를 작성해야 합니다. 이제 C++11에서 추가된 기능을 알아봅시다.

![](/assets/images/코딩테스트-대비-특강/슬라이드42.PNG)
첫 번째로는 STL의 선언 과정에서 `>` 2개가 붙어있어도 된다는 점입니다. C++98에서는 `>` 2개가 붙어있을 때 오류가 발생했지만 C++11에서는 신경쓰지 않아도 됩니다. 그러나 반대로 말하면 C++11이 지원되지 않을 경우 이 부분에 주의를 해야한다는 의미입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드43.PNG)
Tuple은 C++11에 추가된 STL입니다. C++98에 2개의 요소를 묶을 수 있는 STL pair가 있었지만 3개 이상의 요소를 묶을 수 있는 Tuple은 없습니다. Tuple을 이용하면 구조체를 작성하지 않고 편하게 여러 요소를 묶어 관리할 수 있고 Tuple 끼리의 크기 비교 또한 사전 순으로 미리 정해져 있기 때문에 정렬이 필요할 때 편하게 사용할 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드44.PNG)
C++98에서는 중괄호를 이용한 초기화가 불가능한 반면 C++11에서는 가능합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드45.PNG)
C++11에 새로 추가된 tie 함수를 통해 pair, tuple에서 값을 쉽게 뽑아낼 수 있습니다. tuple은 어차피 C++98에 없고, pair는 `.first` 혹은 `.second`로 간편하게 값을 뽑을 수 있기 때문에 큰 영향이 없긴 합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드46.PNG)
C++11에서는 변수의 type을 auto로 지정할 수 있습니다. 그러나 파이썬처럼 변수의 type을 마음대로 바꿀 수 있는 것은 아니고 컴파일을 할 때 auto로 둔 변수의 type이 결정될 수 있어야 하므로 반드시 Initializer가 필요합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드47.PNG)
C++98과 달리 C++11에서는 vector, set, map, 배열 등을 Range-based for를 이용해 더 쉽게 순회할 수 있습니다. 앞에서 소개한 auto의 진가가 여기서 드러나게 되는데, 예를 들어 vector를 순회할 때 `V.begin()`과 `V.end()`를 이용해 `iterator`로 순회를 하고싶다고 하면 C++98에서는 직접 `vector<int>::iterator`라는 다소 낯선 type을 직접 적어줘야 합니다. 그러나 C++11에서는 슬라이드의 4번째 줄과 같이 `auto`로 깔끔하게 처리가 가능합니다. 여기서도 참조자를 이용하면 객체를 복사하는 대신 참조할 수 있게 되는데 이 부분을 따로 공부하시는걸 추천드립니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드48.PNG)
이전까지의 내용은 C/C++ 사용자를 위한 기초 지식들이었습니다. 이제부터는 진짜 알고리즘을 다뤄보도록 하겠습니다. BFS/DFS를 하는 방법 자체는 이미 알고 계신다고 생각하고 여기서 설명하고 가지 않겠습니다. 다차원 배열에서는 BFS 대신 DFS를 사용해야 하는 상황이 존재하지 않습니다.(단, 백트래킹을 해야하는 경우는 예외입니다.) BFS는 Flood Fill과 시작점으로부터의 거리 측정 2가지를 모두 할 수 있지만 DFS는 Flood Fill만 할 수 있기 때문입니다. BFS의 시간복잡도를 잘 모르겠다는 질문을 적어주신 분이 있는데, BFS에서 시간복잡도를 어떻게 계산하면 되는지 알아보겠습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드49.PNG)
[BFS 코드](https://bit.ly/2CLUjk0)를 확인하세요. 이 코드는 제 [실전 알고리즘 강의](https://blog.encrypted.gg/729)에서도 확인할 수 있습니다. 이 코드는 (0, 0)에서 시작해 상하좌우로 인접한 모든 빨간 칸을 방문하는 코드입니다. 빨간 칸은 1에 대응되고 (0, 0)이 빨간 칸임은 보장됩니다. 코드에서 시간복잡도를 파악하기 위해서는 큐에서 원소를 한 번 꺼낼 때 마다 몇 번의 연산을 하는지, 그리고 큐에 원소는 최대 몇 번 들어가게 되는지를 알아야 합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드50.PNG)
큐에서 원소를 꺼낸 후에는 상하좌우로 인접한 4개의 칸에 대해 해당 칸이 아직 방문하지 않은 빨간 칸인지를 확인합니다. 엄밀히 연산의 횟수를 따지면 덧셈의 횟수, 비교의 횟수 등을 깐깐하게 따져야 하지만 그렇게 하지말고 그냥 4번의 연산을 한다고 칩시다. 즉 큐에서 원소를 한 번 꺼낼 때 마다 4번의 연산을 하는 것입니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드51.PNG)
그 다음으로는 전체 while문이 몇 번 돌지 생각해봅시다. 이 말은 곧 큐에서 원소가 몇 번 들어가게 되는지를 의미합니다.  (0, 0)과 인접한 모든 빨간 칸은 큐에 들어가고 `vis`를 이용해 동일한 칸은 많아야 한 번만 큐에 들어가므로 최대 지도의 크기만큼 큐에 들어가게 됩니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드52.PNG)
그러므로 세로 $$N$$, 가로 $$M$$인 이차원 배열에서의 BFS인 경우 시간복잡도는 $$O(NM)$$입니다. 각 원소에서 상하좌우 4칸을 확인하는 과정이 있으므로 $$O(4NM)$$로 적어도 무방합니다.

사실 정확한 원리를 모르더라도 BFS의 시간복잡도는 워낙 다양한 곳에서 언급되어서 알고 계셨을텐데, 단순 BFS가 아니라 몇 가지 다른 과정들이 추가되면 상당히 헷갈려 하시는 것 같아 [BOJ 2146번 : 다리 만들기](https://icpc.me/2146)라는 BFS를 이용한 문제에서 시간복잡도를 같이 계산해보겠습니다. 같이 풀이를 하기 전에 먼저 문제를 풀어보세요.

![](/assets/images/코딩테스트-대비-특강/슬라이드53.PNG)
이 문제의 첫 번째 풀이는 우선 섬을 파악한 후 모든 육지의 칸에서 BFS를 돌려 가장 가까운 섬을 찾는 방법입니다. 섬을 파악하려면 아직 방문하지 않은 육지를 찾아 Flood Fill을 돌면 됩니다. 이 과정에서의 시간복잡도를 알아봅시다.

![](/assets/images/코딩테스트-대비-특강/슬라이드54.PNG)
첫 번째로 모든 칸에 대해 아직 방문하지 않은 육지인지 확인하는 부분에서 $$O(N^2)$$이 필요합니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드55.PNG)
두 번째로 큐로 인해 발생하는 이 반복문이 함수 내에서 총 몇 번 돌지를 생각해봅시다. 이전에 BFS의 시간복잡도를 계산할 때와 마찬가지로 모든 육지는 이 함수가 실행되는 동안 큐에 정확히 한 번씩 들어가기 때문에 최대 $$O(N^2)$$ 입니다. 이 과정에서 Amortized라는 개념을 잘 알아야하는데, 각 $$i, j$$에 대해 $$O(N^2)$$이라는 얘기가 아닙니다. 그렇게 되면 $$O(N^4)$$가 되겠죠. 각 육지는 단 하나의 $$i, j$$에서 등장하기 때문에 이 함수가 실행되는 동안 큐에 정확히 한 번씩 들어간다는 의미입니다. 이 두 가지 경우를 합해보면 코드의 `island` 함수는 $$O(N^2)$$에 동작함을 알 수 있습니다. 

![](/assets/images/코딩테스트-대비-특강/슬라이드56.PNG)
`island` 함수를 통해 섬에 번호를 적절하게 붙인 이후에는 모든 육지에서 BFS를 돌면서 가장 가까운 거리에 있는 다른 섬의 육지를 찾습니다. island 함수에서 미리 전처리를 해서 각 칸에 해당 육지가 몇 번 섬인지를 기록해두었기 때문에 BFS 도는 과정에서 만난 육지가 같은 섬인지 다른 섬인지를 판단할 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드57.PNG)
[정답 코드](http://boj.kr/8b8916381f684f239f1b3183896d0069)를 확인해보세요. `min_bridge` 함수가 $$O(N^2)$$에 실행됨은 자명합니다. 각 바다가 최대 1번 큐에 들어가기 때문입니다. 그리고 `min_bridge` 함수는 모든 육지에 대해 실행되고 육지는 최대 $$N^2$$개이므로 전체 시간복잡도는 $$O(N^4)$$로 계산할 수 있습니다.

그러나 실제로 구현을 해보면 $$N = 100$$이라 $$O(N^4)$$이면 시간 초과를 걱정해야 할 것 같은데 오히려 굉장히 빠르게 동작하는 것을 확인할 수 있습니다. 그 이유를 한 번 생각해보세요. 테스트 케이스가 약해서 그런 것은 절대 아닙니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드58.PNG)
그 이유는 아래와 같습니다.
1. `min_bridge` 함수가 주변에 바다가 인접해있지 않은 육지에서 출발하면 $$O(N^2)$$이 걸리는게 아니라 $$O(1)$$에 종료됩니다.
2. 또한 육지의 갯수가 늘어나면 늘어날수록 섬끼리의 거리가 가까워지기 때문에 `min_bridge` 함수가 이론 상으로는 $$O(N^2)$$이지만 이정도까지 필요하지 않고 빠르게 종료됩니다.
이 경우에는 수학적으로 시간복잡도를 깔끔하게 알기 어렵지만, 일단 $$O(N^4)$$임을 알 수 있고 이후 이렇게 성질들을 관찰함으로서 꽤 빠르게 돌겠다는 추론을 할 수 있습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드59.PNG)
두 번째 풀이는 $$O(N^2)$$에 깔끔하게 풀이가 가능한 풀이입니다. 이 풀이는 우선 섬을 파악한 후, 모든 섬에서 동시에 BFS를 돌려 섬의 영역을 확장하다가 껍데기끼리 겹쳐지는 순간을 찾는 방식입니다. 편의상 세 섬의 색을 달리 표현하겠습니다. [정답 코드](http://boj.kr/53a38e13910642babb85c51de4317064)를 확인해보세요. 여기서 주황색으로 표시된 곳이 만나는 부분들인데, 진한 주황과 옅은 주황은 전 단계의 모양을 참고해 무슨 차이가 있을지 고민해보세요. 

![](/assets/images/코딩테스트-대비-특강/슬라이드60.PNG)
마찬가지로 큐 안에 모든 영역이 최대 1번씩 들어감을 이용해 $$O(N^2)$$임을 알 수 있습니다. 여러 개의 시작점에서 BFS를 돌리는 것을 이번에 처음 보셨다면 조금 헷갈릴 수 있으니 코드를 참고해 직접 코딩해보세요. 여러 개의 시작점에서 BFS를 돌리는 방식으로 구현해야 하는 문제인 [BOJ 5427번 : Fire](https://icpc.me/5427)을 먼저 풀어보신다면 도움이 될 것입니다.

만약 인접한 곳이 다른 섬인 곳을 찾았을 때 `dist[nx][ny]+dist[cur.X][cur.Y]`으로 계산된 값을 바로 출력하고 종료하면 틀린 답을 출력할 수 있습니다. 어떤 경우에 이러한 일이 생길지 고민해보세요.

![](/assets/images/코딩테스트-대비-특강/슬라이드61.PNG)
백트래킹은 정말 헷갈립니다. 그리고 달리 왕도가 없습니다. 이건 어쩔 수가 없습니다. 어떤 인자를 둘 것인지, 각 함수에서는 어디까지 계산하고 다음으로 넘길지를 각 문제의 상황에 맞게 잘 설정해야 합니다. 이를 위해서는 처음에 익숙하지 않으면 다른 사람의 코드를 참고해 구조를 습득하고, 이후엔 다양한 문제를 계속 풀어보는 방법 밖에 없습니다. [그룹](https://www.acmicpc.net/group/4490) 내의 문제집에 있는 문제들을 정복해보세요.

이번 강의에서는 [BOJ 9663번 : N-Queen](https://icpc.me/9663) 문제로 예시를 들어 백트래킹을 설명해보도록 하겠습니다.

![](/assets/images/코딩테스트-대비-특강/슬라이드62.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드63.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드64.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드65.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드66.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드67.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드68.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드69.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드70.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드71.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드72.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드73.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드74.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드75.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드76.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드77.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드78.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드79.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드80.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드81.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드82.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드83.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드84.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드85.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드86.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드87.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드88.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드89.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드90.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드91.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드92.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드93.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드94.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드95.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드96.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드97.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드98.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드99.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드100.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드101.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드102.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드103.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드104.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드105.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드106.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드107.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드108.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드109.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드110.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드111.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드112.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드113.PNG)

![](/assets/images/코딩테스트-대비-특강/슬라이드114.PNG)
